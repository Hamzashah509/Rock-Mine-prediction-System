# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z9LUYg-Ayo3MJHM71CL4u5M4gLB25YV1
"""



"""Importing the required Dependencies

"""

#Import the basic dependencies and keep on importing the dependencies as per need
import numpy as  np
import pandas as pd

"""Data collection and preprocessing"""

# converting the csv file into pandas data frame
sonardata = '/content/sonar_data.csv.csv'
dataset = pd.read_csv(sonardata, header=None)

dataset.head()

dataset.shape

dataset.tail()

dataset.describe()

#The data seems pretty standardize so no need of standardizing of data

#So now lets check the missing values

missing_values = dataset.isnull().sum()

print(missing_values)



"""Training Test Slpit"""

from sklearn.model_selection import train_test_split

#first we need to split the data
X = dataset.drop(60, axis = 1)
Y = dataset[60]

"""Label Encoding Y data"""

from sklearn.preprocessing import LabelEncoder

label_encoder = LabelEncoder()

y_encoded = label_encoder.fit_transform(Y)

Y = y_encoded

# Rock ---> 1
# Mine ---> 0

print(X)

print(Y)

# use train test split
X_train,X_test,Y_train,Y_test = train_test_split(X,Y, stratify=Y, random_state=3)

X_train.shape, X_test.shape, Y_train.shape, Y_test.shape

"""TRAINING THE MODEL"""

#importing the logistic regression
from sklearn.linear_model import LogisticRegression

model = LogisticRegression()

model.fit(X_train, Y_train)

"""Evaluating the model
1 Accuracy Score
2 Confusion Matrix
"""

# 1) Accuracy Score
from sklearn.metrics import accuracy_score

Y_predict = model.predict(X_test)

accuracy = accuracy_score(Y_test, Y_predict)

print("Accuracy:", accuracy)

#2 Confusion Matrix
from sklearn.metrics import confusion_matrix

conf_matrix = confusion_matrix(Y_test, Y_predict)
print("Confusion Matrix:")
print(conf_matrix)

""" Confusion matrix using Matplotlib"""

import matplotlib.pyplot as plt

# Create a confusion matrix plot
plt.figure(figsize=(8, 6))
plt.imshow(conf_matrix, cmap=plt.cm.Blues, interpolation='nearest')
plt.title('Confusion Matrix')
plt.colorbar()

classes = ['Rock', 'Sonar']
tick_marks = np.arange(len(classes))
plt.xticks(tick_marks, classes, rotation=45)
plt.yticks(tick_marks, classes)

for i in range(len(classes)):
    for j in range(len(classes)):
        plt.text(j, i, format(conf_matrix[i, j], 'd'),
                 horizontalalignment="center",
                 color="white" if conf_matrix[i, j] > conf_matrix.max() / 2 else "black")

plt.ylabel('True label')
plt.xlabel('Predicted label')
plt.tight_layout()
plt.show()

"""Make a predictive"""

input_data = (0.0260,0.0363,0.0136,0.0272,0.0214,0.0338,0.0655,0.1400,0.1843,0.2354,0.2720,0.2442,0.1665,0.0336,0.1302,0.1708,0.2177,0.3175,0.3714,0.4552,0.5700,0.7397,0.8062,0.8837,0.9432,1.0000,0.9375,0.7603,0.7123,0.8358,0.7622,0.4567,0.1715,0.1549,0.1641,0.1869,0.2655,0.1713,0.0959,0.0768,0.0847,0.2076,0.2505,0.1862,0.1439,0.1470,0.0991,0.0041,0.0154,0.0116,0.0181,0.0146,0.0129,0.0047,0.0039,0.0061,0.0040,0.0036,0.0061,0.0115)

# Changing the input data to a numpy array
input_data_as_numpy_array = np.asarray(input_data)

# Reshape the np array as we are predicting for one instance
input_data_reshaped = input_data_as_numpy_array.reshape(1, -1)

# Make prediction
prediction = model.predict(input_data_reshaped)

# Decode prediction
decoded_prediction = label_encoder.inverse_transform(prediction)

if(prediction[0] == 1):
  print('The object is a Rock')
else:
  print('The object is a Mine')

